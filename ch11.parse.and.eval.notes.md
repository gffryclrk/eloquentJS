# Egg Language Parser Notes

Working through Chapter 11 of Eloquent JavaScript.
Code reference: ch11.parse.and.eval.js

## 1st Iteration

run() first call: (line 150)
	
run() function first defines environemnt variable by creating an instance of topEnv (line 144). Next run creates array of all arguments passed to it and then joins that array together into a long string using newline characters (line 145).

`var program = Array.prototype....`
returns:

	"do(define(total, 0),
		define(count, 1),
		while(<(count, 11),
			do(define(total, +(total, count)),
				define(count, +(count, 1)))),
		print(total))"

	So program is above string.

run() then returns call to evaluate, where parse(program) is passed as an argument along with env variable. (line 147)

parse(program) defines result variable as return value on call to to parseExpression(program) (line 44)

parseExpression(program) passes program variable to skipSpace() (line 2). skipSpace() makes no changes to string because first character is "d" (line 22).

first characters in string: "do " match third regex: `/^[^\s(),"]+/` and so 

	expr = {type: "word", name: "do" };

parseExpression then returns parseApply(expr, program) where program becomes:

	"(define(total, 0),
		define(count, 1),
		while(<(count, 11),
			do(define(total, +(total, count)),
				define(count, +(count, 1)))),
		print(total))"

parseApply attempts to remove spaces from beginning of program string (line 26) and makes no changes becasue first character is '('. if first character in program is not '('' parseApply() would return an object. However, since it is a '(' character parseApply function slices the first character from the program string (line 31). expr object is defined containing type "apply", operator expr object which was passed as argument and args an empty array (line 32). Thus expr object is:

	expr = {type: "apply", operator: {type: "word", name: "do"}, args: []}

parseApply() then enters while loop which will break upon encountering close parenthesis ')'. Defines arg variable as parseExpression return of program in current state (line 34).

## 2nd Iteration

parseExpression() function is passed the following string: 

	"define(total, 0),
		define(count, 1),
		while(<(count, 11),
			do(define(total, +(total, count)),
				define(count, +(count, 1)))),
		print(total))"

Beginning of string, 'define', matches third regular expression `/^[^\s(),"]` (Line 8). 

	expr = {type: "word", name: "define"}

parseExpression() function returns call to parseApply with expr and the following as arguments:

	"(total, 0),
		define(count, 1),
		while(<(count, 11),
			do(define(total, +(total, count)),
				define(count, +(count, 1)))),
		print(total))"

parseApply first checks for spaces at beginning of program string (line 26), then checks to make sure first character is '(' (line 27). parseApply() then slices first character from beginning of program string (line 31) and defines expr object (line 32) which contains the expr object that was passed as an argument. parseApply thus has an expr object as follows:

	expr = {type: "apply", operator: {type: "word", name: "define"}, args: []}

parseApply() then enters while loop and defines arg variable as return from parseExpression() function.

## 3rd Iteration

parseExpression(program) where program is:

	total, 0),
		define(count, 1),
		while(<(count, 11),
			do(define(total, +(total, count)),
				define(count, +(count, 1)))),
		print(total))

Matches third regular expression: `^[^\s(),"]+` so expr becomes

	expr = {type "word", name: "total"}

function returns call to parseApply with arguments expr, above, and program text with the first 5 characters trimmed off (program.slice(match[0].length)).

parseApply(expr, program) first checks for spaces at the beginning of program string. Since first character is ',' no changes are made. parseApply() function then slices first character off beginning, ',', and passes result to skip space. program text then becomes:

	0),
		define(count, 1),
		while(<(count, 11),
			do(define(total, +(total, count)),
				define(count, +(count, 1)))),
		print(total))

where expr is:

	expr = {type: "apply", operator: {type: "word", name: "total"}, args: []}

A while loop is then entered which will quit upon reaching a close parenthesis ')'. var arg is then deifned as return from call to parseExpression with program string as argument.

## 4th Iteration

parseExpression recieves above program text as argument which satisfies second regex, `^\d+\b/`. expr then becomes `expr = {type: "value", value: 0}`. parseExpression then returns call to parseApply() with expr and program as arguments. However, program has the first character sliced off.

parseApply 



